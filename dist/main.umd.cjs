(function(e,m){typeof exports=="object"&&typeof module<"u"?m(exports):typeof define=="function"&&define.amd?define(["exports"],m):(e=typeof globalThis<"u"?globalThis:e||self,m(e["monads-ts"]={}))})(this,function(e){"use strict";class m{constructor(t){this.value=t}static apply(t,r){return t.isRight()&&r.isRight()?w(t.right()(r.right())):t.isLeft()?t:r}}class g extends m{fold(t,r){return t(this.value)}left(){return this.value}right(){}isLeft(){return!0}isRight(){return!1}tapLeft(t){return t(this.value),this}tapRight(t){return this}map(t){return this}chain(t){return this}toPrimitive(){return{isRight:!1,value:this.value}}getOrElseThrow(){throw this.value}getOrElse(t){return t}}class d extends m{fold(t,r){return r(this.value)}left(){}right(){return this.value}isLeft(){return!1}isRight(){return!0}tapLeft(t){return this}tapRight(t){return t(this.value),this}map(t){return new d(t(this.value))}chain(t){return t(this.value)}toPrimitive(){return{isRight:!0,value:this.value}}getOrElseThrow(){return this.value}getOrElse(t){return this.value}}const w=s=>new d(s),c=s=>new g(s),V=m.apply;class f{constructor(t){this.value=t}static of(t){return new f(t)}static apply(t,r){return t.isNothing()||r.isNothing()?f.of(null):f.of(t.value(r.value))}isNothing(){return this.value===null||this.value===void 0}tap(t){return this.isNothing()||t(this.value),this}map(t){return this.isNothing()?f.of(null):f.of(t(this.value))}ap(t){return f.apply(this,t)}join(){return this.isNothing()?f.of(null):this.value}chain(t){return this.map(t).join()}getOrElse(t){return this.isNothing()?t:this.value}get(){return this.value??null}toEither(t){return this.isNothing()?c(t):w(this.value)}fold(t,r){return this.isNothing()?t():r(this.value)}}const C=()=>f.of(null),k=f.of,W=f.apply,I=s=>s instanceof m?s:s instanceof Error||typeof s=="string"?c(s):c(`Unknown error: ${s}`);class u{constructor(t){this.run=t}static sequence(t){return t.length===0?u.right([]):t.reduce((n,i)=>n.chain(v=>u.from(()=>i.fold(N=>c(N),N=>w([...v,N])))),u.right([]))}static parsePrimitiveEither(t){return t===null?{isRight:!1,value:"Null value from TaskEither.fromPrimitives"}:t===void 0?{isRight:!1,value:"Undefined value from TaskEither.fromPrimitives"}:typeof t=="object"&&"isRight"in t?t:t instanceof m?t.toPrimitive():{isRight:!1,value:t}}static fromPrimitives(t){const r=u.parsePrimitiveEither(t);return r.isRight?u.of(w(r.value)):u.of(c(r.value))}static from(t){return new u(()=>t().catch(I))}static of(t){const r=k(t).getOrElse(c("Invalid value from TaskEither.of"));return new u(()=>Promise.resolve(r))}static right(t){return u.of(w(t))}static left(t){return u.of(c(t))}static appply(t,r){return u.from(async()=>{const n=await t.run(),i=await r.run();if(n.isLeft())return c(n.left());if(i.isLeft())return c(i.left());const v=n.right(),N=i.right();return w(v(N))})}async fold(t,r){return this.run().then(n=>n.fold(t,r))}left(){return this.fold(t=>t,t=>{})}right(){return this.fold(t=>{},t=>t)}isLeft(){return this.fold(t=>!0,t=>!1)}isRight(){return this.fold(t=>!1,t=>!0)}map(t){return new u(()=>this.run().then(r=>r.fold(n=>Promise.resolve(new g(n)),n=>Promise.resolve(new d(t(n))))).catch(I))}tap(t){return new u(()=>this.run().then(r=>r.fold(n=>Promise.resolve(new g(n)),async n=>(t(n),new d(n)))))}chain(t){return new u(()=>this.run().then(r=>r.fold(n=>Promise.resolve(new g(n)),n=>t(n).run())))}chainLeft(t){return new u(()=>this.run().then(r=>r.fold(n=>t(n).run(),n=>Promise.resolve(new d(n)))))}async getOrElse(t){return(await this.run()).fold(()=>t,n=>n)}async getOrElseThrow(t){return(await this.run()).fold(n=>Promise.reject(n??t??"Error from TaskEither"),n=>n)}async toPrimitive(){return this.run().then(t=>t.toPrimitive())}}const $=u.from,q=u.of,F=u.appply;class o{constructor(t){this.effect=t}static from(t){return new o(t)}static void(t){return new o(async()=>{await t()})}static of(t){return new o(()=>Promise.resolve(t))}static rejected(t){return new o(()=>Promise.reject(t))}static apply(t,r){return new o(async()=>{const n=await t.run(),i=await r.run();return n(i)})}async run(){return this.effect()}map(t){return new o(async()=>t(await this.run()))}tap(t){return new o(async()=>{const r=await this.run();return t(r),r})}chain(t){return new o(async()=>t(await this.run()).run())}toEither(t){return u.from(()=>this.run().then(r=>w(r)).catch(r=>k(t).map(n=>c(n(r))).getOrElse(c(r))))}}const M=o.from,z=o.apply;class l{constructor(t){this.effect=t}static apply(t,r){return new l(()=>t.run()(r.run()))}static of(t){return new l(()=>t)}static reject(t){return new l(()=>{throw t})}run(){return this.effect()}tap(t){return new l(()=>{const r=this.run();return t(r),r})}map(t){return new l(()=>t(this.run()))}chain(t){return new l(()=>t(this.run()).run())}fold(t,r){try{return r(this.run())}catch{return t()}}}const B=l.of,D=l.apply;class y{constructor(t){this.effect=t}static from(t){return new y(t)}run(t){return this.effect(t)}map(t){return new y(r=>this.run(r).map(t))}chain(t){return new y(r=>this.run(r).chain(n=>t(n).fold(r,i=>c(i),w)))}fold(t,r,n){return this.run(t).fold(r,n)}}class E{constructor(t){this.effect=t}static from(t){return new E(t)}run(t){return this.effect(t)}map(t){return new E(r=>this.run(r).map(t))}chain(t){return new E(r=>this.run(r).chain(n=>t(n).fold(r,()=>l.reject(new Error("IO rejected")),l.of)))}fold(t,r,n){try{return n(this.run(t).run())}catch(i){return r(i)}}}class P{constructor(t){this.effect=t}static from(t){return new P(t)}run(t){return this.effect(t)}map(t){return new P(r=>this.run(r).map(t))}chain(t){return new P(r=>this.run(r).chain(n=>t(n).fold(r,()=>C(),k)))}fold(t,r,n){return this.run(t).fold(r,n)}}class a{constructor(t){this.run=t}static from(t){return new a(t)}static fromIO(t){return new a(r=>t(r).run())}static fromEither(t){return new a(r=>t(r).getOrElseThrow())}static of(t){return new a(()=>t)}static ofEither(t){return new a(()=>t.getOrElseThrow())}static ask(){return new a(t=>t)}static apply(t,r){return new a(n=>{const i=t.run(n),v=r.run(n);return i(v)})}ask(){return a.ask()}map(t){return new a(r=>t(this.run(r)))}chain(t){return new a(r=>t(this.run(r)).run(r))}chainContext(t,r){return this.chain(n=>A(t,r(n)))}toEither(t,r){try{return w(this.run(t))}catch(n){return c(r?r(t):n)}}}const G=a.from,H=a.fromIO,J=a.fromEither,K=a.ask,Q=a.of,R=a.apply;function A(s,t){return a.from(r=>t.run(s(r)))}class T{}const O=(s,t)=>[s,t];class p{constructor(t){this.run=t}static of(t){return new p(r=>O(t,r))}static from(t){return new p(t)}map(t){return new p(r=>{const[n,i]=this.run(r);return O(t(n),i)})}tap(t){return new p(r=>{const[n,i]=this.run(r);return t(n),O(n,i)})}tapEffect(t){return new p(r=>{const[n,i]=this.run(r);return t(i),O(n,i)})}chain(t){return new p(r=>{const[n,i]=this.run(r);return t(n).run(i)})}runWith(t){return this.run(t)}evalWith(t){return this.run(t)[0]}execWith(t){return this.run(t)[1]}}class j{constructor(t){this.effect=t}static from(t){return new j(t)}run(t){return this.effect(t)}map(t){return new j(r=>this.run(r).map(t))}chain(t){return new j(r=>this.run(r).chain(n=>u.from(()=>t(n).fold(r,i=>c(i),w))))}fold(t,r,n){return this.run(t).fold(r,n)}}class L{constructor(t){this.effect=t}static from(t){return new L(t)}run(t){return this.effect(t)}map(t){return new L(r=>this.run(r).map(t))}chain(t){return new L(r=>this.run(r).chain(n=>o.from(()=>t(n).fold(r,i=>{throw new Error(`Unexpected error ${i}`)},i=>i))))}fold(t,r,n){return this.run(t).run().then(n).catch(r)}}class h{constructor(t){this.run=t}static from(t){return new h(t)}static fromTaskIO(t){return new h(r=>t(r).run())}static fromTaskEither(t){return new h(r=>t(r).getOrElseThrow())}static fromReader(t){return new h(r=>Promise.resolve(t(r).run(r)))}static of(t){return new h(()=>Promise.resolve(t))}static ofEither(t){return new h(async()=>t.getOrElseThrow())}static ofReader(t){return new h(r=>Promise.resolve(t.run(r)))}static ask(){return new h(async t=>t)}static apply(t,r){return new h(async n=>{const i=await t.run(n),v=await r.run(n);return i(v)})}ask(){return h.ask()}map(t){return new h(r=>this.run(r).then(t))}tap(t){return this.map(r=>(t(r),r))}chain(t){return new h(r=>this.run(r).then(n=>t(n).run(r)))}chainContext(t,r){return this.chain(n=>U(t,r(n)))}toEither(t,r){return o.from(async()=>this.run(t)).toEither(r)}}const X=h.fromTaskIO,Y=h.fromTaskEither,Z=h.apply;function U(s,t){return h.from(r=>t.run(s(r)))}class S{}e.Either=m,e.EitherReaderT=y,e.EitherTaskReaderT=j,e.IO=l,e.IOReaderT=E,e.IOTaskReaderT=L,e.IReaderT=T,e.ITaskReaderT=S,e.Left=g,e.Maybe=f,e.MaybeReaderT=P,e.Pair=O,e.Reader=a,e.Right=d,e.State=p,e.TaskEither=u,e.TaskIO=o,e.TaskReader=h,e.applyEither=V,e.applyIO=D,e.applyMaybe=W,e.applyTaskEither=F,e.applyTaskIO=z,e.applyTaskReader=Z,e.io=B,e.left=c,e.maybe=k,e.nothing=C,e.reader=G,e.readerApply=R,e.readerAsk=K,e.readerEither=J,e.readerIO=H,e.readerMapContext=A,e.readerOf=Q,e.readerTask=X,e.readerTaskEither=Y,e.readerTaskMapContext=U,e.right=w,e.taskEither=$,e.taskEitherOf=q,e.taskIO=M,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});
